//--------------------------------------------------------------------
//TTMGNetwork  -- this will encapsulate interaction with the database
//--------------------------------------------------------------------

import YDB from 'nodem'  //YDB is an object

const global_ydb=YDB.Ydb();  //executed once when file is first imported
                     //if imported from multiple files, still only run once. 
console.log(global_ydb.open());
console.log(global_ydb.version());    

export class TTMGNetwork extends EventTarget
{
  constructor(input) {
    super();      
    this.AProp1 = input;
    this.ydb=global_ydb;
  }
  
  setData(...argArray) { 
    let data = this.ydb.set(...argArray);
    console.log("result of ydb set",data);
    return data;
  }
  
  getData(...argArray) { 
    let data = this.ydb.get(...argArray);
    console.log("result of ydb get",data);
    return data;
  }
  
  close() {
    console.log("closing database");
    this.ydb.close();  // Close connection to YottaDB, releasing resources and restoring terminal settings    
  }

  mumpsFn(...argArray) {
    let data = this.ydb.function(...argArray);
    return data
  }

  /**
   * Calls a Mumps RPC. All arguments are implicitly passed by reference,
   * with objects/arrays automatically stringified to JSON for Mumps-side decoding.
   * The function returns a JSON object containing the final values of all arguments
   * after the Mumps RPC execution.
   * Supports both Promise-based (async/await) and callback-based asynchronous patterns.
   *
   * @param {string} tag The tag name of the Mumps function to call (e.g., 'MYFN').
   * @param {string} rtn The routine name where the Mumps function is defined (e.g., 'MYROUTINE').
   * @param {Array<any>} args An array of arguments to pass to the Mumps function.
   * Objects/arrays will be automatically stringified to JSON and marked for decoding/re-encoding.
   * @param {function} [callback] Optional callback function `(error, result)` for asynchronous operation.
   * The `result` will be an object with keys like 'arg0', 'arg1', etc., containing final argument values.
   * @returns {Promise<object>|undefined} A promise that resolves with an object containing final argument values,
   * or rejects with an error if the call fails. Returns undefined if a callback is provided.
   */
  RPC(tag, rtn, args = [], callback) { // 'args' is now directly a parameter
    const ydb = this.ydb;
    const mumpsAPIFn="NODEAPI^TMGNODE1"
    const hasCallback = typeof callback === 'function';

    // Prepare arguments for the Mumps call, including type metadata
    const preparedMumpsArgs = args.map((arg, index) => {
        let valueToSend;
        let originalType;

        // Auto-detect type and stringify objects/arrays
        if (typeof arg === 'object' && arg !== null) {
            valueToSend = JSON.stringify(arg);
            originalType = Array.isArray(arg) ? 'json_array' : 'json_object';
        } else {
            valueToSend = arg;
            originalType = typeof arg === 'number' ? 'number' : 'string'; // Assume simple types are string/number
        }

        return {
            value: valueToSend,
            type: originalType,
            // All arguments are now considered pass-by-reference implicitly
        };
    });

    // Stringify the entire preparedMumpsArgs array for the single JSONARGS Mumps argument
    const finalJsonArgsForMumps = JSON.stringify(preparedMumpsArgs);

    // Construct the Mumps-side arguments array for the ydb.function() call
    // This will always call the NODEAPI^NODEAPI intermediary.
    const mumpsFnArgs = [tag, rtn, finalJsonArgsForMumps];

    const processResult = (nodemResult) => {
      // The result from Mumps is expected to be a JSON string of the returned arguments
      if (!nodemResult || !nodemResult.ok) { // Check for nodem-level 'ok' flag first
          const errorMessage = (nodemResult && nodemResult.errorMessage) || 'Unknown RPC error from nodem';
          const errorCode = (nodemResult && nodemResult.errorCode) || 'N/A';
          throw new Error(`Mumps function 'NODEAPI^NODEAPI' failed: [Code: ${errorCode}] ${errorMessage}`);
      }
      
      try {
        const finalResults = JSON.parse(nodemResult.result);
        return finalResults; // This will be an object like { arg0: "value", arg1: { ... } }
      } catch (parseError) {
        throw new Error(`Failed to parse Mumps result as JSON. Result: '${nodemResult.result}'. Error: ${parseError.message}`);
      }
    };

    if (hasCallback) {
      try {
        this.ydb.function({ // Using .function() as requested
          function: mumpsAPIFn,
          arguments: mumpsFnArgs
        }, (error, nodemResult) => {
          if (error) {
            return callback(new Error(`RPC call failed before Mumps execution: ${error.message}`));
          }
          try {
            const finalResult = processResult(nodemResult);
            callback(null, finalResult);
          } catch (processingError) {
            callback(processingError);
          }
        });
      } catch (syncError) {
        callback(syncError);
      }
      return undefined;
    } else {
      return new Promise(async (resolve, reject) => {
        let nodemResult;
        try {
          nodemResult = await this.ydb.function({ 
            function: mumpsAPIFn,
            arguments: mumpsFnArgs
          });
        } catch (error) {
          return reject(new Error(`RPC call failed before Mumps execution: ${error.message}`));
        }

        try {
          const finalResult = processResult(nodemResult);
          resolve(finalResult);
        } catch (processingError) {
          reject(processingError);
        }
      });
    }
  }

  // Example Usage (assuming tmg is your nodem connection instance):
  /*
  // Basic string arguments and string result
  (async () => {
    try {
        // Example Mumps function: MYFN^MYROUTINE(arg1, arg2) that returns a string
        const result1 = await RPC('MYFN', 'MYROUTINE', {
            args: ['hello', 123, 'world']
        });
        console.log('Result 1 (string):', result1); // Expects a string
  
        // Example Mumps function: MYJSONFN^MYROUTINE(jsonString) that returns a JSON string
        const result2 = await RPC('MYJSONFN', 'MYROUTINE', {
            args: [{ key: 'value', num: 42 }],
            resultFormat: 'json'
        });
        console.log('Result 2 (JSON object):', result2); // Expects a parsed JSON object
  
        // Example with no arguments
        const result3 = await RPC('NOARGSFN', 'MYROUTINE', {
            args: [],
            resultFormat: 'string'
        });
        console.log('Result 3 (string, no args):', result3); // Expects a string
  
    } catch (error) {
        console.error('RPC Error:', error.message);
    }
  })();
  */
  
  myFN1() {
    //something here
    console.log(this.AProp1);
  }    
    
  myFN2() {
    //something here
    this.myFN1();
  }    
}    

//local, for testing only. 
//sample from linux console:   npx nodemon TTMGNetwork.js

let tmgNetwork = new TTMGNetwork('hello');
tmgNetwork.myFN2();
